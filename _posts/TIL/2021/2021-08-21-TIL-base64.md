---
layout: post
title: Base64 인코딩
tags: [TIL]
excerpt: "TIL - Base64 인코딩"
date: 2021-08-21
feature: https://github.com/younggeun0/younggeun0.github.io/blob/master/_posts/img/til/til.png?raw=true
comments: true
---
 
## Base64 인코딩

> Base64 인코딩은 이진 데이터를 안전하게 만들어줌

* Base64 인코딩은 임의의 바이트들의 연속을, 더 길지만 헤더 필드 값으로 사용할 수 있는 일반적인 문자로만 이루어진 문자열을 반환
  * HTTP 파서를 망가뜨릴 수 있는 콜론(:), 줄바꿈, 혹은 이진값을 포함할 걱정 없이 HTTP 헤더 필드 값으로 보낼 수 있게 됨
* Base64 인코딩은 MIME 멀티미디어 전자 메일 표준의 일부로 개발됨
  * MIME은 이를 이용해 오래된 이메일 게이트웨이 사이에서도 복잡한 텍스트나 임의의 이진 데이터를 실어 나를 수 있었음

> 8비트를 6비트로

### Base64 인코딩 순서

1. 8비트 바이트들의 연속을 받아 6비트의 조각의 연속으로 쪼갬 (문자열의 크기는 원래 값보다 33% 커짐)
2. 각 6비트 조각을 Base64 알파벳으로 이루어진 64개의 글자 중 하나에 할당 (64개의 글자들은 HTTP 헤더 필드에 놓여도 안전한 글자들)
3. 64문자들은 대문자, 소문자, 숫자, '+', '/', '='를 포함

```bash
# 8비트 문자
O w !

# 8비트 값 (16진수)
$4F $77 $21

# 8비트 값 (2진수)
0100111101110111001000001

# 6비트 값 (10진수)
19 55 28 33

# base 64 문자
T 3 c h
```


### Base64 패딩

* Base64 인코딩은 일련의 8비트 바이트들을 받아 그 비트 스트림을 6비트 덩어리로 조각냄
  * 6비트 조각으로 고르게 나눠지는 일은 별로 없음, 6비트 조각으로 고르게 나뉘지 않으면 그 길이를 24비트(6비트와 8비트의 최소공배수)로 만들고 남은 공간은 0비트로 채움
* 패딩된 비트 문자열은 인코딩할 때 원 데이터에서 어떤 비트도 포함하지 않은 완전히 패딩된 6비트의 그룹은 특별한 65번째 기호인 '='로 표현됨
  * 만약 6비트의 그룹이 부분적으로 패딩됐다면 패딩 비트들은 모두 0으로 설정됨

```bash
# 입력 데이터 
a:a
# 이진 수열
011000 010011 101001 100001
# 인코딩된 데이터
Y3ph

# 입력 데이터 
a:aa
#이진 수열 (패딩은 'x'로 표현)
011000 010011 101001 100001 011000 01xxxx xxxxxxxx xxxxxxxx
# 인코딩된 데이터
YTphYQ==
```

---

### 참고
* HTTP The Definitive Guide 부록 E
* [RFC 2045 6.8절](http://www.ietf.org/rfc/rfc2045.txt)
